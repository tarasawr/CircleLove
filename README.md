Использовал как чистое ООП, так и Zenject (приоритет был на отказ от MonoBehaviour и сокращении количества Inject). Делал упор на кодовую базу, а UI и эффекты в рамках тестового задания уделил меньше времени.

- Передвижение игрока: реализовано через DOTween, так как считаю, что в рамках проекта это целесообразно из-за быстроты реализации и легкости поддержки. Есть альтернативный способ с использованием математических функций, но я боюсь, что кроме меня никто не поймёт такой код.
- PathService: основан на измерении пути с помощью Vector3.Dot. Существует вариант использовать коэффициент времени, но он приводит к неточностям в определении пройденного пути.
- EnemyFactory: фабрика, использующая нативный UnityPool – оптимизированное решение, которое эффективнее кастомного пуллинга.
- SaveSystem: реализована через JSON (самый распространённый способ). Существует множество вариантов, но благодаря использованию интерфейса мы всегда можем подменить нужную реализацию.
- ConfigService: работает с ScriptableObject, что удобно как для дизайнеров, так и для разработчиков. Также имеется возможность расширения сервиса для работы с удалёнными конфигурациями (это демонстрирует направление моих дальнейших мыслей).
- PositionProvider: ищет свободное место на экране с проверками на дедлок.
- IInputService: реализован с использованием UniRx.
- AddressableService - кеширует префабы, что позволяет нам иметь быстрый доступ к ним.
